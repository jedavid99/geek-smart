{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { messages as defaultMessages, newMessages } from \"./messages\";\nimport { asyncMap, complementError, convertFieldsError, deepMerge, format, warning } from \"./util\";\nimport validators from \"./validator/index\";\nexport * from \"./interface\";\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\n\nvar Schema = /*#__PURE__*/function () {\n  function Schema(descriptor) {\n    _classCallCheck(this, Schema); // ======================== Instance ========================\n\n\n    _defineProperty(this, \"rules\", null);\n\n    _defineProperty(this, \"_messages\", defaultMessages);\n\n    this.define(descriptor);\n  }\n\n  _createClass(Schema, [{\n    key: \"define\",\n    value: function define(rules) {\n      var _this = this;\n\n      if (!rules) {\n        throw new Error('Cannot configure a schema with no rules');\n      }\n\n      if (_typeof(rules) !== 'object' || Array.isArray(rules)) {\n        throw new Error('Rules must be an object');\n      }\n\n      this.rules = {};\n      Object.keys(rules).forEach(function (name) {\n        var item = rules[name];\n        _this.rules[name] = Array.isArray(item) ? item : [item];\n      });\n    }\n  }, {\n    key: \"messages\",\n    value: function messages(_messages) {\n      if (_messages) {\n        this._messages = deepMerge(newMessages(), _messages);\n      }\n\n      return this._messages;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(source_) {\n      var _this2 = this;\n\n      var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var oc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n      var source = source_;\n      var options = o;\n      var callback = oc;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (!this.rules || Object.keys(this.rules).length === 0) {\n        if (callback) {\n          callback(null, source);\n        }\n\n        return Promise.resolve(source);\n      }\n\n      function complete(results) {\n        var errors = [];\n        var fields = {};\n\n        function add(e) {\n          if (Array.isArray(e)) {\n            var _errors;\n\n            errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e));\n          } else {\n            errors.push(e);\n          }\n        }\n\n        for (var i = 0; i < results.length; i++) {\n          add(results[i]);\n        }\n\n        if (!errors.length) {\n          callback(null, source);\n        } else {\n          fields = convertFieldsError(errors);\n          callback(errors, fields);\n        }\n      }\n\n      if (options.messages) {\n        var messages = this.messages();\n\n        if (messages === defaultMessages) {\n          messages = newMessages();\n        }\n\n        deepMerge(messages, options.messages);\n        options.messages = messages;\n      } else {\n        options.messages = this.messages();\n      }\n\n      var series = {};\n      var keys = options.keys || Object.keys(this.rules);\n      keys.forEach(function (z) {\n        var arr = _this2.rules[z];\n        var value = source[z];\n        arr.forEach(function (r) {\n          var rule = r;\n\n          if (typeof rule.transform === 'function') {\n            if (source === source_) {\n              source = _objectSpread({}, source);\n            }\n\n            value = source[z] = rule.transform(value);\n\n            if (value !== undefined && value !== null) {\n              rule.type = rule.type || (Array.isArray(value) ? 'array' : _typeof(value));\n            }\n          }\n\n          if (typeof rule === 'function') {\n            rule = {\n              validator: rule\n            };\n          } else {\n            rule = _objectSpread({}, rule);\n          } // Fill validator. Skip if nothing need to validate\n\n\n          rule.validator = _this2.getValidationMethod(rule);\n\n          if (!rule.validator) {\n            return;\n          }\n\n          rule.field = z;\n          rule.fullField = rule.fullField || z;\n          rule.type = _this2.getType(rule);\n          series[z] = series[z] || [];\n          series[z].push({\n            rule: rule,\n            value: value,\n            source: source,\n            field: z\n          });\n        });\n      });\n      var errorFields = {};\n      return asyncMap(series, options, function (data, doIt) {\n        var rule = data.rule;\n        var deep = (rule.type === 'object' || rule.type === 'array') && (_typeof(rule.fields) === 'object' || _typeof(rule.defaultField) === 'object');\n        deep = deep && (rule.required || !rule.required && data.value);\n        rule.field = data.field;\n\n        function addFullField(key, schema) {\n          return _objectSpread(_objectSpread({}, schema), {}, {\n            fullField: \"\".concat(rule.fullField, \".\").concat(key),\n            fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]\n          });\n        }\n\n        function cb() {\n          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          var errorList = Array.isArray(e) ? e : [e];\n\n          if (!options.suppressWarning && errorList.length) {\n            Schema.warning('async-validator:', errorList);\n          }\n\n          if (errorList.length && rule.message !== undefined) {\n            errorList = [].concat(rule.message);\n          } // Fill error info\n\n\n          var filledErrors = errorList.map(complementError(rule, source));\n\n          if (options.first && filledErrors.length) {\n            errorFields[rule.field] = 1;\n            return doIt(filledErrors);\n          }\n\n          if (!deep) {\n            doIt(filledErrors);\n          } else {\n            // if rule is required but the target object\n            // does not exist fail at the rule level and don't\n            // go deeper\n            if (rule.required && !data.value) {\n              if (rule.message !== undefined) {\n                filledErrors = [].concat(rule.message).map(complementError(rule, source));\n              } else if (options.error) {\n                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];\n              }\n\n              return doIt(filledErrors);\n            }\n\n            var fieldsSchema = {};\n\n            if (rule.defaultField) {\n              Object.keys(data.value).map(function (key) {\n                fieldsSchema[key] = rule.defaultField;\n              });\n            }\n\n            fieldsSchema = _objectSpread(_objectSpread({}, fieldsSchema), data.rule.fields);\n            var paredFieldsSchema = {};\n            Object.keys(fieldsSchema).forEach(function (field) {\n              var fieldSchema = fieldsSchema[field];\n              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];\n              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n            });\n            var schema = new Schema(paredFieldsSchema);\n            schema.messages(options.messages);\n\n            if (data.rule.options) {\n              data.rule.options.messages = options.messages;\n              data.rule.options.error = options.error;\n            }\n\n            schema.validate(data.value, data.rule.options || options, function (errs) {\n              var finalErrors = [];\n\n              if (filledErrors && filledErrors.length) {\n                finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));\n              }\n\n              if (errs && errs.length) {\n                finalErrors.push.apply(finalErrors, _toConsumableArray(errs));\n              }\n\n              doIt(finalErrors.length ? finalErrors : null);\n            });\n          }\n        }\n\n        var res;\n\n        if (rule.asyncValidator) {\n          res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n        } else if (rule.validator) {\n          try {\n            res = rule.validator(rule, data.value, cb, data.source, options);\n          } catch (error) {\n            var _console$error, _console;\n\n            (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error); // rethrow to report error\n\n            if (!options.suppressValidatorError) {\n              setTimeout(function () {\n                throw error;\n              }, 0);\n            }\n\n            cb(error.message);\n          }\n\n          if (res === true) {\n            cb();\n          } else if (res === false) {\n            cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || \"\".concat(rule.fullField || rule.field, \" fails\"));\n          } else if (res instanceof Array) {\n            cb(res);\n          } else if (res instanceof Error) {\n            cb(res.message);\n          }\n        }\n\n        if (res && res.then) {\n          res.then(function () {\n            return cb();\n          }, function (e) {\n            return cb(e);\n          });\n        }\n      }, function (results) {\n        complete(results);\n      }, source);\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(rule) {\n      if (rule.type === undefined && rule.pattern instanceof RegExp) {\n        rule.type = 'pattern';\n      }\n\n      if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {\n        throw new Error(format('Unknown rule type %s', rule.type));\n      }\n\n      return rule.type || 'string';\n    }\n  }, {\n    key: \"getValidationMethod\",\n    value: function getValidationMethod(rule) {\n      if (typeof rule.validator === 'function') {\n        return rule.validator;\n      }\n\n      var keys = Object.keys(rule);\n      var messageIndex = keys.indexOf('message');\n\n      if (messageIndex !== -1) {\n        keys.splice(messageIndex, 1);\n      }\n\n      if (keys.length === 1 && keys[0] === 'required') {\n        return validators.required;\n      }\n\n      return validators[this.getType(rule)] || undefined;\n    }\n  }]);\n\n  return Schema;\n}(); // ========================= Static =========================\n\n\n_defineProperty(Schema, \"register\", function register(type, validator) {\n  if (typeof validator !== 'function') {\n    throw new Error('Cannot register a validator by type, validator is not a function');\n  }\n\n  validators[type] = validator;\n});\n\n_defineProperty(Schema, \"warning\", warning);\n\n_defineProperty(Schema, \"messages\", defaultMessages);\n\n_defineProperty(Schema, \"validators\", validators);\n\nexport default Schema;","map":{"version":3,"sources":["C:/Users/david/Documents/GitHub/geek-smart/node_modules/@rc-component/async-validator/es/index.js"],"names":["_objectSpread","_toConsumableArray","_typeof","_classCallCheck","_createClass","_defineProperty","messages","defaultMessages","newMessages","asyncMap","complementError","convertFieldsError","deepMerge","format","warning","validators","Schema","descriptor","define","key","value","rules","_this","Error","Array","isArray","Object","keys","forEach","name","item","_messages","validate","source_","_this2","o","arguments","length","undefined","oc","source","options","callback","Promise","resolve","complete","results","errors","fields","add","e","_errors","concat","apply","push","i","series","z","arr","r","rule","transform","type","validator","getValidationMethod","field","fullField","getType","errorFields","data","doIt","deep","defaultField","required","addFullField","schema","fullFields","cb","errorList","suppressWarning","message","filledErrors","map","first","error","fieldsSchema","paredFieldsSchema","fieldSchema","fieldSchemaList","bind","errs","finalErrors","res","asyncValidator","_console$error","_console","console","call","suppressValidatorError","setTimeout","then","pattern","RegExp","hasOwnProperty","messageIndex","indexOf","splice","register"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,0CAA1B;AACA,OAAOC,kBAAP,MAA+B,8CAA/B;AACA,OAAOC,OAAP,MAAoB,mCAApB;AACA,OAAOC,eAAP,MAA4B,2CAA5B;AACA,OAAOC,YAAP,MAAyB,wCAAzB;AACA,OAAOC,eAAP,MAA4B,2CAA5B;AACA,SAASC,QAAQ,IAAIC,eAArB,EAAsCC,WAAtC,QAAyD,YAAzD;AACA,SAASC,QAAT,EAAmBC,eAAnB,EAAoCC,kBAApC,EAAwDC,SAAxD,EAAmEC,MAAnE,EAA2EC,OAA3E,QAA0F,QAA1F;AACA,OAAOC,UAAP,MAAuB,mBAAvB;AACA,cAAc,aAAd;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,MAAM,GAAG,aAAa,YAAY;AACpC,WAASA,MAAT,CAAgBC,UAAhB,EAA4B;AAC1Bd,IAAAA,eAAe,CAAC,IAAD,EAAOa,MAAP,CAAf,CAD0B,CAE1B;;;AACAX,IAAAA,eAAe,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAhB,CAAf;;AACAA,IAAAA,eAAe,CAAC,IAAD,EAAO,WAAP,EAAoBE,eAApB,CAAf;;AACA,SAAKW,MAAL,CAAYD,UAAZ;AACD;;AACDb,EAAAA,YAAY,CAACY,MAAD,EAAS,CAAC;AACpBG,IAAAA,GAAG,EAAE,QADe;AAEpBC,IAAAA,KAAK,EAAE,SAASF,MAAT,CAAgBG,KAAhB,EAAuB;AAC5B,UAAIC,KAAK,GAAG,IAAZ;;AACA,UAAI,CAACD,KAAL,EAAY;AACV,cAAM,IAAIE,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,UAAIrB,OAAO,CAACmB,KAAD,CAAP,KAAmB,QAAnB,IAA+BG,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAnC,EAAyD;AACvD,cAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD,WAAKF,KAAL,GAAa,EAAb;AACAK,MAAAA,MAAM,CAACC,IAAP,CAAYN,KAAZ,EAAmBO,OAAnB,CAA2B,UAAUC,IAAV,EAAgB;AACzC,YAAIC,IAAI,GAAGT,KAAK,CAACQ,IAAD,CAAhB;AACAP,QAAAA,KAAK,CAACD,KAAN,CAAYQ,IAAZ,IAAoBL,KAAK,CAACC,OAAN,CAAcK,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAAjD;AACD,OAHD;AAID;AAfmB,GAAD,EAgBlB;AACDX,IAAAA,GAAG,EAAE,UADJ;AAEDC,IAAAA,KAAK,EAAE,SAASd,QAAT,CAAkByB,SAAlB,EAA6B;AAClC,UAAIA,SAAJ,EAAe;AACb,aAAKA,SAAL,GAAiBnB,SAAS,CAACJ,WAAW,EAAZ,EAAgBuB,SAAhB,CAA1B;AACD;;AACD,aAAO,KAAKA,SAAZ;AACD;AAPA,GAhBkB,EAwBlB;AACDZ,IAAAA,GAAG,EAAE,UADJ;AAEDC,IAAAA,KAAK,EAAE,SAASY,QAAT,CAAkBC,OAAlB,EAA2B;AAChC,UAAIC,MAAM,GAAG,IAAb;;AACA,UAAIC,CAAC,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA5E;AACA,UAAIG,EAAE,GAAGH,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,YAAY,CAAE,CAA3F;AACA,UAAII,MAAM,GAAGP,OAAb;AACA,UAAIQ,OAAO,GAAGN,CAAd;AACA,UAAIO,QAAQ,GAAGH,EAAf;;AACA,UAAI,OAAOE,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,QAAAA,QAAQ,GAAGD,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD;;AACD,UAAI,CAAC,KAAKpB,KAAN,IAAeK,MAAM,CAACC,IAAP,CAAY,KAAKN,KAAjB,EAAwBgB,MAAxB,KAAmC,CAAtD,EAAyD;AACvD,YAAIK,QAAJ,EAAc;AACZA,UAAAA,QAAQ,CAAC,IAAD,EAAOF,MAAP,CAAR;AACD;;AACD,eAAOG,OAAO,CAACC,OAAR,CAAgBJ,MAAhB,CAAP;AACD;;AACD,eAASK,QAAT,CAAkBC,OAAlB,EAA2B;AACzB,YAAIC,MAAM,GAAG,EAAb;AACA,YAAIC,MAAM,GAAG,EAAb;;AACA,iBAASC,GAAT,CAAaC,CAAb,EAAgB;AACd,cAAI1B,KAAK,CAACC,OAAN,CAAcyB,CAAd,CAAJ,EAAsB;AACpB,gBAAIC,OAAJ;;AACAJ,YAAAA,MAAM,GAAG,CAACI,OAAO,GAAGJ,MAAX,EAAmBK,MAAnB,CAA0BC,KAA1B,CAAgCF,OAAhC,EAAyClD,kBAAkB,CAACiD,CAAD,CAA3D,CAAT;AACD,WAHD,MAGO;AACLH,YAAAA,MAAM,CAACO,IAAP,CAAYJ,CAAZ;AACD;AACF;;AACD,aAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,OAAO,CAACT,MAA5B,EAAoCkB,CAAC,EAArC,EAAyC;AACvCN,UAAAA,GAAG,CAACH,OAAO,CAACS,CAAD,CAAR,CAAH;AACD;;AACD,YAAI,CAACR,MAAM,CAACV,MAAZ,EAAoB;AAClBK,UAAAA,QAAQ,CAAC,IAAD,EAAOF,MAAP,CAAR;AACD,SAFD,MAEO;AACLQ,UAAAA,MAAM,GAAGrC,kBAAkB,CAACoC,MAAD,CAA3B;AACAL,UAAAA,QAAQ,CAACK,MAAD,EAASC,MAAT,CAAR;AACD;AACF;;AACD,UAAIP,OAAO,CAACnC,QAAZ,EAAsB;AACpB,YAAIA,QAAQ,GAAG,KAAKA,QAAL,EAAf;;AACA,YAAIA,QAAQ,KAAKC,eAAjB,EAAkC;AAChCD,UAAAA,QAAQ,GAAGE,WAAW,EAAtB;AACD;;AACDI,QAAAA,SAAS,CAACN,QAAD,EAAWmC,OAAO,CAACnC,QAAnB,CAAT;AACAmC,QAAAA,OAAO,CAACnC,QAAR,GAAmBA,QAAnB;AACD,OAPD,MAOO;AACLmC,QAAAA,OAAO,CAACnC,QAAR,GAAmB,KAAKA,QAAL,EAAnB;AACD;;AACD,UAAIkD,MAAM,GAAG,EAAb;AACA,UAAI7B,IAAI,GAAGc,OAAO,CAACd,IAAR,IAAgBD,MAAM,CAACC,IAAP,CAAY,KAAKN,KAAjB,CAA3B;AACAM,MAAAA,IAAI,CAACC,OAAL,CAAa,UAAU6B,CAAV,EAAa;AACxB,YAAIC,GAAG,GAAGxB,MAAM,CAACb,KAAP,CAAaoC,CAAb,CAAV;AACA,YAAIrC,KAAK,GAAGoB,MAAM,CAACiB,CAAD,CAAlB;AACAC,QAAAA,GAAG,CAAC9B,OAAJ,CAAY,UAAU+B,CAAV,EAAa;AACvB,cAAIC,IAAI,GAAGD,CAAX;;AACA,cAAI,OAAOC,IAAI,CAACC,SAAZ,KAA0B,UAA9B,EAA0C;AACxC,gBAAIrB,MAAM,KAAKP,OAAf,EAAwB;AACtBO,cAAAA,MAAM,GAAGxC,aAAa,CAAC,EAAD,EAAKwC,MAAL,CAAtB;AACD;;AACDpB,YAAAA,KAAK,GAAGoB,MAAM,CAACiB,CAAD,CAAN,GAAYG,IAAI,CAACC,SAAL,CAAezC,KAAf,CAApB;;AACA,gBAAIA,KAAK,KAAKkB,SAAV,IAAuBlB,KAAK,KAAK,IAArC,EAA2C;AACzCwC,cAAAA,IAAI,CAACE,IAAL,GAAYF,IAAI,CAACE,IAAL,KAActC,KAAK,CAACC,OAAN,CAAcL,KAAd,IAAuB,OAAvB,GAAiClB,OAAO,CAACkB,KAAD,CAAtD,CAAZ;AACD;AACF;;AACD,cAAI,OAAOwC,IAAP,KAAgB,UAApB,EAAgC;AAC9BA,YAAAA,IAAI,GAAG;AACLG,cAAAA,SAAS,EAAEH;AADN,aAAP;AAGD,WAJD,MAIO;AACLA,YAAAA,IAAI,GAAG5D,aAAa,CAAC,EAAD,EAAK4D,IAAL,CAApB;AACD,WAjBsB,CAmBvB;;;AACAA,UAAAA,IAAI,CAACG,SAAL,GAAiB7B,MAAM,CAAC8B,mBAAP,CAA2BJ,IAA3B,CAAjB;;AACA,cAAI,CAACA,IAAI,CAACG,SAAV,EAAqB;AACnB;AACD;;AACDH,UAAAA,IAAI,CAACK,KAAL,GAAaR,CAAb;AACAG,UAAAA,IAAI,CAACM,SAAL,GAAiBN,IAAI,CAACM,SAAL,IAAkBT,CAAnC;AACAG,UAAAA,IAAI,CAACE,IAAL,GAAY5B,MAAM,CAACiC,OAAP,CAAeP,IAAf,CAAZ;AACAJ,UAAAA,MAAM,CAACC,CAAD,CAAN,GAAYD,MAAM,CAACC,CAAD,CAAN,IAAa,EAAzB;AACAD,UAAAA,MAAM,CAACC,CAAD,CAAN,CAAUH,IAAV,CAAe;AACbM,YAAAA,IAAI,EAAEA,IADO;AAEbxC,YAAAA,KAAK,EAAEA,KAFM;AAGboB,YAAAA,MAAM,EAAEA,MAHK;AAIbyB,YAAAA,KAAK,EAAER;AAJM,WAAf;AAMD,SAlCD;AAmCD,OAtCD;AAuCA,UAAIW,WAAW,GAAG,EAAlB;AACA,aAAO3D,QAAQ,CAAC+C,MAAD,EAASf,OAAT,EAAkB,UAAU4B,IAAV,EAAgBC,IAAhB,EAAsB;AACrD,YAAIV,IAAI,GAAGS,IAAI,CAACT,IAAhB;AACA,YAAIW,IAAI,GAAG,CAACX,IAAI,CAACE,IAAL,KAAc,QAAd,IAA0BF,IAAI,CAACE,IAAL,KAAc,OAAzC,MAAsD5D,OAAO,CAAC0D,IAAI,CAACZ,MAAN,CAAP,KAAyB,QAAzB,IAAqC9C,OAAO,CAAC0D,IAAI,CAACY,YAAN,CAAP,KAA+B,QAA1H,CAAX;AACAD,QAAAA,IAAI,GAAGA,IAAI,KAAKX,IAAI,CAACa,QAAL,IAAiB,CAACb,IAAI,CAACa,QAAN,IAAkBJ,IAAI,CAACjD,KAA7C,CAAX;AACAwC,QAAAA,IAAI,CAACK,KAAL,GAAaI,IAAI,CAACJ,KAAlB;;AACA,iBAASS,YAAT,CAAsBvD,GAAtB,EAA2BwD,MAA3B,EAAmC;AACjC,iBAAO3E,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK2E,MAAL,CAAd,EAA4B,EAA5B,EAAgC;AAClDT,YAAAA,SAAS,EAAE,GAAGd,MAAH,CAAUQ,IAAI,CAACM,SAAf,EAA0B,GAA1B,EAA+Bd,MAA/B,CAAsCjC,GAAtC,CADuC;AAElDyD,YAAAA,UAAU,EAAEhB,IAAI,CAACgB,UAAL,GAAkB,GAAGxB,MAAH,CAAUnD,kBAAkB,CAAC2D,IAAI,CAACgB,UAAN,CAA5B,EAA+C,CAACzD,GAAD,CAA/C,CAAlB,GAA0E,CAACA,GAAD;AAFpC,WAAhC,CAApB;AAID;;AACD,iBAAS0D,EAAT,GAAc;AACZ,cAAI3B,CAAC,GAAGd,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA5E;AACA,cAAI0C,SAAS,GAAGtD,KAAK,CAACC,OAAN,CAAcyB,CAAd,IAAmBA,CAAnB,GAAuB,CAACA,CAAD,CAAvC;;AACA,cAAI,CAACT,OAAO,CAACsC,eAAT,IAA4BD,SAAS,CAACzC,MAA1C,EAAkD;AAChDrB,YAAAA,MAAM,CAACF,OAAP,CAAe,kBAAf,EAAmCgE,SAAnC;AACD;;AACD,cAAIA,SAAS,CAACzC,MAAV,IAAoBuB,IAAI,CAACoB,OAAL,KAAiB1C,SAAzC,EAAoD;AAClDwC,YAAAA,SAAS,GAAG,GAAG1B,MAAH,CAAUQ,IAAI,CAACoB,OAAf,CAAZ;AACD,WARW,CAUZ;;;AACA,cAAIC,YAAY,GAAGH,SAAS,CAACI,GAAV,CAAcxE,eAAe,CAACkD,IAAD,EAAOpB,MAAP,CAA7B,CAAnB;;AACA,cAAIC,OAAO,CAAC0C,KAAR,IAAiBF,YAAY,CAAC5C,MAAlC,EAA0C;AACxC+B,YAAAA,WAAW,CAACR,IAAI,CAACK,KAAN,CAAX,GAA0B,CAA1B;AACA,mBAAOK,IAAI,CAACW,YAAD,CAAX;AACD;;AACD,cAAI,CAACV,IAAL,EAAW;AACTD,YAAAA,IAAI,CAACW,YAAD,CAAJ;AACD,WAFD,MAEO;AACL;AACA;AACA;AACA,gBAAIrB,IAAI,CAACa,QAAL,IAAiB,CAACJ,IAAI,CAACjD,KAA3B,EAAkC;AAChC,kBAAIwC,IAAI,CAACoB,OAAL,KAAiB1C,SAArB,EAAgC;AAC9B2C,gBAAAA,YAAY,GAAG,GAAG7B,MAAH,CAAUQ,IAAI,CAACoB,OAAf,EAAwBE,GAAxB,CAA4BxE,eAAe,CAACkD,IAAD,EAAOpB,MAAP,CAA3C,CAAf;AACD,eAFD,MAEO,IAAIC,OAAO,CAAC2C,KAAZ,EAAmB;AACxBH,gBAAAA,YAAY,GAAG,CAACxC,OAAO,CAAC2C,KAAR,CAAcxB,IAAd,EAAoB/C,MAAM,CAAC4B,OAAO,CAACnC,QAAR,CAAiBmE,QAAlB,EAA4Bb,IAAI,CAACK,KAAjC,CAA1B,CAAD,CAAf;AACD;;AACD,qBAAOK,IAAI,CAACW,YAAD,CAAX;AACD;;AACD,gBAAII,YAAY,GAAG,EAAnB;;AACA,gBAAIzB,IAAI,CAACY,YAAT,EAAuB;AACrB9C,cAAAA,MAAM,CAACC,IAAP,CAAY0C,IAAI,CAACjD,KAAjB,EAAwB8D,GAAxB,CAA4B,UAAU/D,GAAV,EAAe;AACzCkE,gBAAAA,YAAY,CAAClE,GAAD,CAAZ,GAAoByC,IAAI,CAACY,YAAzB;AACD,eAFD;AAGD;;AACDa,YAAAA,YAAY,GAAGrF,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKqF,YAAL,CAAd,EAAkChB,IAAI,CAACT,IAAL,CAAUZ,MAA5C,CAA5B;AACA,gBAAIsC,iBAAiB,GAAG,EAAxB;AACA5D,YAAAA,MAAM,CAACC,IAAP,CAAY0D,YAAZ,EAA0BzD,OAA1B,CAAkC,UAAUqC,KAAV,EAAiB;AACjD,kBAAIsB,WAAW,GAAGF,YAAY,CAACpB,KAAD,CAA9B;AACA,kBAAIuB,eAAe,GAAGhE,KAAK,CAACC,OAAN,CAAc8D,WAAd,IAA6BA,WAA7B,GAA2C,CAACA,WAAD,CAAjE;AACAD,cAAAA,iBAAiB,CAACrB,KAAD,CAAjB,GAA2BuB,eAAe,CAACN,GAAhB,CAAoBR,YAAY,CAACe,IAAb,CAAkB,IAAlB,EAAwBxB,KAAxB,CAApB,CAA3B;AACD,aAJD;AAKA,gBAAIU,MAAM,GAAG,IAAI3D,MAAJ,CAAWsE,iBAAX,CAAb;AACAX,YAAAA,MAAM,CAACrE,QAAP,CAAgBmC,OAAO,CAACnC,QAAxB;;AACA,gBAAI+D,IAAI,CAACT,IAAL,CAAUnB,OAAd,EAAuB;AACrB4B,cAAAA,IAAI,CAACT,IAAL,CAAUnB,OAAV,CAAkBnC,QAAlB,GAA6BmC,OAAO,CAACnC,QAArC;AACA+D,cAAAA,IAAI,CAACT,IAAL,CAAUnB,OAAV,CAAkB2C,KAAlB,GAA0B3C,OAAO,CAAC2C,KAAlC;AACD;;AACDT,YAAAA,MAAM,CAAC3C,QAAP,CAAgBqC,IAAI,CAACjD,KAArB,EAA4BiD,IAAI,CAACT,IAAL,CAAUnB,OAAV,IAAqBA,OAAjD,EAA0D,UAAUiD,IAAV,EAAgB;AACxE,kBAAIC,WAAW,GAAG,EAAlB;;AACA,kBAAIV,YAAY,IAAIA,YAAY,CAAC5C,MAAjC,EAAyC;AACvCsD,gBAAAA,WAAW,CAACrC,IAAZ,CAAiBD,KAAjB,CAAuBsC,WAAvB,EAAoC1F,kBAAkB,CAACgF,YAAD,CAAtD;AACD;;AACD,kBAAIS,IAAI,IAAIA,IAAI,CAACrD,MAAjB,EAAyB;AACvBsD,gBAAAA,WAAW,CAACrC,IAAZ,CAAiBD,KAAjB,CAAuBsC,WAAvB,EAAoC1F,kBAAkB,CAACyF,IAAD,CAAtD;AACD;;AACDpB,cAAAA,IAAI,CAACqB,WAAW,CAACtD,MAAZ,GAAqBsD,WAArB,GAAmC,IAApC,CAAJ;AACD,aATD;AAUD;AACF;;AACD,YAAIC,GAAJ;;AACA,YAAIhC,IAAI,CAACiC,cAAT,EAAyB;AACvBD,UAAAA,GAAG,GAAGhC,IAAI,CAACiC,cAAL,CAAoBjC,IAApB,EAA0BS,IAAI,CAACjD,KAA/B,EAAsCyD,EAAtC,EAA0CR,IAAI,CAAC7B,MAA/C,EAAuDC,OAAvD,CAAN;AACD,SAFD,MAEO,IAAImB,IAAI,CAACG,SAAT,EAAoB;AACzB,cAAI;AACF6B,YAAAA,GAAG,GAAGhC,IAAI,CAACG,SAAL,CAAeH,IAAf,EAAqBS,IAAI,CAACjD,KAA1B,EAAiCyD,EAAjC,EAAqCR,IAAI,CAAC7B,MAA1C,EAAkDC,OAAlD,CAAN;AACD,WAFD,CAEE,OAAO2C,KAAP,EAAc;AACd,gBAAIU,cAAJ,EAAoBC,QAApB;;AACA,aAACD,cAAc,GAAG,CAACC,QAAQ,GAAGC,OAAZ,EAAqBZ,KAAvC,MAAkD,IAAlD,IAA0DU,cAAc,KAAK,KAAK,CAAlF,IAAuFA,cAAc,CAACG,IAAf,CAAoBF,QAApB,EAA8BX,KAA9B,CAAvF,CAFc,CAGd;;AACA,gBAAI,CAAC3C,OAAO,CAACyD,sBAAb,EAAqC;AACnCC,cAAAA,UAAU,CAAC,YAAY;AACrB,sBAAMf,KAAN;AACD,eAFS,EAEP,CAFO,CAAV;AAGD;;AACDP,YAAAA,EAAE,CAACO,KAAK,CAACJ,OAAP,CAAF;AACD;;AACD,cAAIY,GAAG,KAAK,IAAZ,EAAkB;AAChBf,YAAAA,EAAE;AACH,WAFD,MAEO,IAAIe,GAAG,KAAK,KAAZ,EAAmB;AACxBf,YAAAA,EAAE,CAAC,OAAOjB,IAAI,CAACoB,OAAZ,KAAwB,UAAxB,GAAqCpB,IAAI,CAACoB,OAAL,CAAapB,IAAI,CAACM,SAAL,IAAkBN,IAAI,CAACK,KAApC,CAArC,GAAkFL,IAAI,CAACoB,OAAL,IAAgB,GAAG5B,MAAH,CAAUQ,IAAI,CAACM,SAAL,IAAkBN,IAAI,CAACK,KAAjC,EAAwC,QAAxC,CAAnG,CAAF;AACD,WAFM,MAEA,IAAI2B,GAAG,YAAYpE,KAAnB,EAA0B;AAC/BqD,YAAAA,EAAE,CAACe,GAAD,CAAF;AACD,WAFM,MAEA,IAAIA,GAAG,YAAYrE,KAAnB,EAA0B;AAC/BsD,YAAAA,EAAE,CAACe,GAAG,CAACZ,OAAL,CAAF;AACD;AACF;;AACD,YAAIY,GAAG,IAAIA,GAAG,CAACQ,IAAf,EAAqB;AACnBR,UAAAA,GAAG,CAACQ,IAAJ,CAAS,YAAY;AACnB,mBAAOvB,EAAE,EAAT;AACD,WAFD,EAEG,UAAU3B,CAAV,EAAa;AACd,mBAAO2B,EAAE,CAAC3B,CAAD,CAAT;AACD,WAJD;AAKD;AACF,OA1Gc,EA0GZ,UAAUJ,OAAV,EAAmB;AACpBD,QAAAA,QAAQ,CAACC,OAAD,CAAR;AACD,OA5Gc,EA4GZN,MA5GY,CAAf;AA6GD;AAzMA,GAxBkB,EAkOlB;AACDrB,IAAAA,GAAG,EAAE,SADJ;AAEDC,IAAAA,KAAK,EAAE,SAAS+C,OAAT,CAAiBP,IAAjB,EAAuB;AAC5B,UAAIA,IAAI,CAACE,IAAL,KAAcxB,SAAd,IAA2BsB,IAAI,CAACyC,OAAL,YAAwBC,MAAvD,EAA+D;AAC7D1C,QAAAA,IAAI,CAACE,IAAL,GAAY,SAAZ;AACD;;AACD,UAAI,OAAOF,IAAI,CAACG,SAAZ,KAA0B,UAA1B,IAAwCH,IAAI,CAACE,IAA7C,IAAqD,CAAC/C,UAAU,CAACwF,cAAX,CAA0B3C,IAAI,CAACE,IAA/B,CAA1D,EAAgG;AAC9F,cAAM,IAAIvC,KAAJ,CAAUV,MAAM,CAAC,sBAAD,EAAyB+C,IAAI,CAACE,IAA9B,CAAhB,CAAN;AACD;;AACD,aAAOF,IAAI,CAACE,IAAL,IAAa,QAApB;AACD;AAVA,GAlOkB,EA6OlB;AACD3C,IAAAA,GAAG,EAAE,qBADJ;AAEDC,IAAAA,KAAK,EAAE,SAAS4C,mBAAT,CAA6BJ,IAA7B,EAAmC;AACxC,UAAI,OAAOA,IAAI,CAACG,SAAZ,KAA0B,UAA9B,EAA0C;AACxC,eAAOH,IAAI,CAACG,SAAZ;AACD;;AACD,UAAIpC,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYiC,IAAZ,CAAX;AACA,UAAI4C,YAAY,GAAG7E,IAAI,CAAC8E,OAAL,CAAa,SAAb,CAAnB;;AACA,UAAID,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACvB7E,QAAAA,IAAI,CAAC+E,MAAL,CAAYF,YAAZ,EAA0B,CAA1B;AACD;;AACD,UAAI7E,IAAI,CAACU,MAAL,KAAgB,CAAhB,IAAqBV,IAAI,CAAC,CAAD,CAAJ,KAAY,UAArC,EAAiD;AAC/C,eAAOZ,UAAU,CAAC0D,QAAlB;AACD;;AACD,aAAO1D,UAAU,CAAC,KAAKoD,OAAL,CAAaP,IAAb,CAAD,CAAV,IAAkCtB,SAAzC;AACD;AAfA,GA7OkB,CAAT,CAAZ;;AA8PA,SAAOtB,MAAP;AACD,CAvQyB,EAA1B,C,CAwQA;;;AACAX,eAAe,CAACW,MAAD,EAAS,UAAT,EAAqB,SAAS2F,QAAT,CAAkB7C,IAAlB,EAAwBC,SAAxB,EAAmC;AACrE,MAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;AACnC,UAAM,IAAIxC,KAAJ,CAAU,kEAAV,CAAN;AACD;;AACDR,EAAAA,UAAU,CAAC+C,IAAD,CAAV,GAAmBC,SAAnB;AACD,CALc,CAAf;;AAMA1D,eAAe,CAACW,MAAD,EAAS,SAAT,EAAoBF,OAApB,CAAf;;AACAT,eAAe,CAACW,MAAD,EAAS,UAAT,EAAqBT,eAArB,CAAf;;AACAF,eAAe,CAACW,MAAD,EAAS,YAAT,EAAuBD,UAAvB,CAAf;;AACA,eAAeC,MAAf","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { messages as defaultMessages, newMessages } from \"./messages\";\nimport { asyncMap, complementError, convertFieldsError, deepMerge, format, warning } from \"./util\";\nimport validators from \"./validator/index\";\nexport * from \"./interface\";\n\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\nvar Schema = /*#__PURE__*/function () {\n  function Schema(descriptor) {\n    _classCallCheck(this, Schema);\n    // ======================== Instance ========================\n    _defineProperty(this, \"rules\", null);\n    _defineProperty(this, \"_messages\", defaultMessages);\n    this.define(descriptor);\n  }\n  _createClass(Schema, [{\n    key: \"define\",\n    value: function define(rules) {\n      var _this = this;\n      if (!rules) {\n        throw new Error('Cannot configure a schema with no rules');\n      }\n      if (_typeof(rules) !== 'object' || Array.isArray(rules)) {\n        throw new Error('Rules must be an object');\n      }\n      this.rules = {};\n      Object.keys(rules).forEach(function (name) {\n        var item = rules[name];\n        _this.rules[name] = Array.isArray(item) ? item : [item];\n      });\n    }\n  }, {\n    key: \"messages\",\n    value: function messages(_messages) {\n      if (_messages) {\n        this._messages = deepMerge(newMessages(), _messages);\n      }\n      return this._messages;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(source_) {\n      var _this2 = this;\n      var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var oc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n      var source = source_;\n      var options = o;\n      var callback = oc;\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      if (!this.rules || Object.keys(this.rules).length === 0) {\n        if (callback) {\n          callback(null, source);\n        }\n        return Promise.resolve(source);\n      }\n      function complete(results) {\n        var errors = [];\n        var fields = {};\n        function add(e) {\n          if (Array.isArray(e)) {\n            var _errors;\n            errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e));\n          } else {\n            errors.push(e);\n          }\n        }\n        for (var i = 0; i < results.length; i++) {\n          add(results[i]);\n        }\n        if (!errors.length) {\n          callback(null, source);\n        } else {\n          fields = convertFieldsError(errors);\n          callback(errors, fields);\n        }\n      }\n      if (options.messages) {\n        var messages = this.messages();\n        if (messages === defaultMessages) {\n          messages = newMessages();\n        }\n        deepMerge(messages, options.messages);\n        options.messages = messages;\n      } else {\n        options.messages = this.messages();\n      }\n      var series = {};\n      var keys = options.keys || Object.keys(this.rules);\n      keys.forEach(function (z) {\n        var arr = _this2.rules[z];\n        var value = source[z];\n        arr.forEach(function (r) {\n          var rule = r;\n          if (typeof rule.transform === 'function') {\n            if (source === source_) {\n              source = _objectSpread({}, source);\n            }\n            value = source[z] = rule.transform(value);\n            if (value !== undefined && value !== null) {\n              rule.type = rule.type || (Array.isArray(value) ? 'array' : _typeof(value));\n            }\n          }\n          if (typeof rule === 'function') {\n            rule = {\n              validator: rule\n            };\n          } else {\n            rule = _objectSpread({}, rule);\n          }\n\n          // Fill validator. Skip if nothing need to validate\n          rule.validator = _this2.getValidationMethod(rule);\n          if (!rule.validator) {\n            return;\n          }\n          rule.field = z;\n          rule.fullField = rule.fullField || z;\n          rule.type = _this2.getType(rule);\n          series[z] = series[z] || [];\n          series[z].push({\n            rule: rule,\n            value: value,\n            source: source,\n            field: z\n          });\n        });\n      });\n      var errorFields = {};\n      return asyncMap(series, options, function (data, doIt) {\n        var rule = data.rule;\n        var deep = (rule.type === 'object' || rule.type === 'array') && (_typeof(rule.fields) === 'object' || _typeof(rule.defaultField) === 'object');\n        deep = deep && (rule.required || !rule.required && data.value);\n        rule.field = data.field;\n        function addFullField(key, schema) {\n          return _objectSpread(_objectSpread({}, schema), {}, {\n            fullField: \"\".concat(rule.fullField, \".\").concat(key),\n            fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]\n          });\n        }\n        function cb() {\n          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          var errorList = Array.isArray(e) ? e : [e];\n          if (!options.suppressWarning && errorList.length) {\n            Schema.warning('async-validator:', errorList);\n          }\n          if (errorList.length && rule.message !== undefined) {\n            errorList = [].concat(rule.message);\n          }\n\n          // Fill error info\n          var filledErrors = errorList.map(complementError(rule, source));\n          if (options.first && filledErrors.length) {\n            errorFields[rule.field] = 1;\n            return doIt(filledErrors);\n          }\n          if (!deep) {\n            doIt(filledErrors);\n          } else {\n            // if rule is required but the target object\n            // does not exist fail at the rule level and don't\n            // go deeper\n            if (rule.required && !data.value) {\n              if (rule.message !== undefined) {\n                filledErrors = [].concat(rule.message).map(complementError(rule, source));\n              } else if (options.error) {\n                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];\n              }\n              return doIt(filledErrors);\n            }\n            var fieldsSchema = {};\n            if (rule.defaultField) {\n              Object.keys(data.value).map(function (key) {\n                fieldsSchema[key] = rule.defaultField;\n              });\n            }\n            fieldsSchema = _objectSpread(_objectSpread({}, fieldsSchema), data.rule.fields);\n            var paredFieldsSchema = {};\n            Object.keys(fieldsSchema).forEach(function (field) {\n              var fieldSchema = fieldsSchema[field];\n              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];\n              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n            });\n            var schema = new Schema(paredFieldsSchema);\n            schema.messages(options.messages);\n            if (data.rule.options) {\n              data.rule.options.messages = options.messages;\n              data.rule.options.error = options.error;\n            }\n            schema.validate(data.value, data.rule.options || options, function (errs) {\n              var finalErrors = [];\n              if (filledErrors && filledErrors.length) {\n                finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));\n              }\n              if (errs && errs.length) {\n                finalErrors.push.apply(finalErrors, _toConsumableArray(errs));\n              }\n              doIt(finalErrors.length ? finalErrors : null);\n            });\n          }\n        }\n        var res;\n        if (rule.asyncValidator) {\n          res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n        } else if (rule.validator) {\n          try {\n            res = rule.validator(rule, data.value, cb, data.source, options);\n          } catch (error) {\n            var _console$error, _console;\n            (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);\n            // rethrow to report error\n            if (!options.suppressValidatorError) {\n              setTimeout(function () {\n                throw error;\n              }, 0);\n            }\n            cb(error.message);\n          }\n          if (res === true) {\n            cb();\n          } else if (res === false) {\n            cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || \"\".concat(rule.fullField || rule.field, \" fails\"));\n          } else if (res instanceof Array) {\n            cb(res);\n          } else if (res instanceof Error) {\n            cb(res.message);\n          }\n        }\n        if (res && res.then) {\n          res.then(function () {\n            return cb();\n          }, function (e) {\n            return cb(e);\n          });\n        }\n      }, function (results) {\n        complete(results);\n      }, source);\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(rule) {\n      if (rule.type === undefined && rule.pattern instanceof RegExp) {\n        rule.type = 'pattern';\n      }\n      if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {\n        throw new Error(format('Unknown rule type %s', rule.type));\n      }\n      return rule.type || 'string';\n    }\n  }, {\n    key: \"getValidationMethod\",\n    value: function getValidationMethod(rule) {\n      if (typeof rule.validator === 'function') {\n        return rule.validator;\n      }\n      var keys = Object.keys(rule);\n      var messageIndex = keys.indexOf('message');\n      if (messageIndex !== -1) {\n        keys.splice(messageIndex, 1);\n      }\n      if (keys.length === 1 && keys[0] === 'required') {\n        return validators.required;\n      }\n      return validators[this.getType(rule)] || undefined;\n    }\n  }]);\n  return Schema;\n}();\n// ========================= Static =========================\n_defineProperty(Schema, \"register\", function register(type, validator) {\n  if (typeof validator !== 'function') {\n    throw new Error('Cannot register a validator by type, validator is not a function');\n  }\n  validators[type] = validator;\n});\n_defineProperty(Schema, \"warning\", warning);\n_defineProperty(Schema, \"messages\", defaultMessages);\n_defineProperty(Schema, \"validators\", validators);\nexport default Schema;"]},"metadata":{},"sourceType":"module"}